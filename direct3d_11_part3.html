<!DOCTYPE html>	<html lang="en">		<head>		  <title>Games Craft</title>		  <meta charset="utf-8">		  <meta name="viewport" content="width=device-width, initial-scale=1">		  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">		  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">		  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>		  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>		  <link rel="stylesheet" type="text/css" href="style.css">		</head><nav class="navbar navbar-default" style="background-color: white; color: #f5f6f7;">	  <div class="container">	    <div class="navbar-header">	      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">	        <span class="icon-bar"></span>	        <span class="icon-bar"></span>	        <span class="icon-bar"></span>	      </button>	      <a class="navbar-left" href="./index.html#"><img style="width: 3cm;" src="./photos/logo.png"></a>	    </div>	    <div class="collapse navbar-collapse" id="myNavbar">	      <ul class="nav navbar-nav navbar-right"  style="margin-top: 25px;">	        <li><a href="./index.html">Articles</a></li>			<li><a href="./minecraft_blog.html">Minecraft Blog</a></li>			<li><a href="./adventure_game_blog.html">Topdown Adventure Blog</a></li>	      	<li><a href="./games_dojo.html">Projects</a></li>	      </ul>	    </div>	  </div>	</nav>	<body>	<div class="container"><div class="row">
<div class="col-sm-10 col-md-12 col-lg-12">
<div class="info-card">
<h1>Direct3d 11 for games: Part 3</h1><h2>Drawing a Colorful Triangle</h2><br></div>
</div>
</div>
<div class="row">
<div class="col-sm-10 col-md-12 col-lg-12">
<div class="info-card">
<p>
The humble Triangle. The backbone of 3d graphics. Everything we draw in games ends up as triangles on the GPU. Even the most complex AAA uses triangles. But why?Â </p>
<br><p>
There are a number of reasons why triangles are ideal for 3d graphics:</p>
<br><p>
1. Triangles always stay triangles after being projected from the 3d world to your computer screen. If we try drawing a square in 3d space and project that onto the screen, depending on the rotation, it could be a whole range of weird shapes. If we know we are only ever drawing and filling triangles, we can make a processor that is very fast at filling in 2d triangles (called the GPU).Â </p>
<br><p>
2. Any set of three points are always coplanar. That is, it is guaranteed that we can form a plane out of any three points. If you think about four points, one of them could lie off the plane the other three points form. Being coplanar is a property that is needed to interpolate values across the surface of a triangle in 3d space, like texture coordinates, normal vectors, and colors.</p>
<br><hr><p>
So our next step on our Direct3D journey is to render a triangle. This lays the ground for rendering more complex things like cubes and models.Â </p>
<br><p>
In this lesson, we're going to be creating the vertex and pixel shader to render the triangle. We are then going to upload the vertex data of the triangle to the GPU. Then in the game loop, we will use our shaders and vertex buffer to draw the triangle into the back buffer each frame. Let's get started!</p>
<br><hr><h2>Contents</h2><br><h4><a href='#id0'> Creating the Vertex and PixelÂ shader</a></h4><br><h4><a href='#id1'> Compile Our Shaders</a></h4><br><h4><a href='#id2'> Create the Vertex Buffer</a></h4><br><h4><a href='#id3'> Create the Input Layout for the Vertex Buffer</a></h4><br><h4><a href='#id4'> Rendering our Triangle eachÂ frame</a></h4><br><h4><a href='#id5'> Set the Viewport size</a></h4><br><h4><a href='#id6'> Set our Render Target</a></h4><br><h4><a href='#id7'> Bind our Input Layout, Shaders and Vertex Buffer</a></h4><br><h4><a href='#id8'> Submit a Draw Call to the GPU</a></h4><br><h4><a href='#id9'> Add the d3dCompiler header and link</a></h4><br><h4><a href='#id10'> Conclusion</a></h4><br><h4><a href='#id11'> Quiz</a></h4><br><hr><h2><span id='id0'><h2> Creating the Vertex and PixelÂ shader</h2><br></span></h2><p>
When we tell the GPU to draw our triangle, it runs each vertex through a vertex shader to calculate the position on the screen in NDC coordinates. NDC coordinates are the screen coordinates ranging from -1 to 1 on the X and Y axis with (0, 0) in the middle of the viewport (in our case the middle of our window). Once the triangle is formed, the GPU will then run the pixel shader for each pixel inside the triangle, interpolating values across the face of the triangle (like color, texture coordinates etc.).</p>
<br><p>
So the first thing we'll do is create a new file that will be our shader- let's call it shader.hlsl (hlsl is the extension for direct3d shaders).</p>
<br><p>
This file will look like this:</p>
<br><div class="code-block-left "><span style="color: #CD950C;">struct </span>VS_Input
<br>{
<br><span style='white-space: pre;'>    </span>float2 pos : POS;
<br><span style='white-space: pre;'>    </span>float4 color : COL;
<br>};
<br><br><span style="color: #CD950C;">struct </span>VS_Output
<br>{
<br><span style='white-space: pre;'>    </span>float4 position : SV_POSITION;
<br><span style='white-space: pre;'>    </span>float4 color : COL;
<br>};
<br><br>VS_Output <span style="color: #CD950C;">vs_main</span><span style="color: #A08563;">(</span>VS_Input input<span style="color: #A08563;">)</span>
<br>{
<br><span style='white-space: pre;'>    </span>VS_Output output;
<br><span style='white-space: pre;'>    </span>output.position = <span style="color: #CD950C;">float4</span><span style="color: #A08563;">(</span>input.pos, <span style="color: #6B8E23;">0.0f, </span><span style="color: #6B8E23;">1.0f</span><span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span>output.color = input.color;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">return </span>output;
<br>}
<br><br>float4 <span style="color: #CD950C;">ps_main</span><span style="color: #A08563;">(</span>VS_Output input<span style="color: #A08563;">)</span> : SV_TARGET
<br>{
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">return </span>input.color;   
<br>}
<br></div><br><p>
Our vertex shader starts at vs_main with the input type of VS_Input. What's contained in VS_Input is the input data for each Vertex. In this case, each vertex will have a float2 position (the x,y screen axis) and a float4 color. TheÂ : POS andÂ : COL aside the values in VS_Input are a way to specify which data is which in the vertex buffer we upload. Since The vertex buffer could be a long list of values interleaved together like so: <i>PosxPosYColorRColorGColorBColorA</i>, we have to tell Direct3D what incoming values link up to what variables in the shader (which we'll see when we upload the vertex data to the GPU).</p>
<br><p>
As each vertex is processed by the vertex shader, it will transform it into Clip Space (one step before NDC space). In this case, we're just leaving the vertex xy values the same and adding a zero depth. The Vertex shader must return a float4 position as seen in the VS_Output Struct. This special value is marked with aÂ : SV_POSITION next to it. This is the vertex in Clip space. Four values is needed because the Graphics Card will divide the x,y,z values by the w value implicitly turning it from Clip Space to NDC space. </p>
<br><p>
The output of the Vertex shader then comes into the Pixel shader as the input. These values aren't the exact values we set in the Vertex shader, they instead are the values interpolated across the triangle's face. This lets us see things like what the position and color at each pixel are instead of just at each of the corners. The only thing the pixel shader has to return is the color of the pixel. In this case, we set it to the incoming color value. You can return up to 8, 32-bit, 4-component colors if writing to multiple buffers at once or no color if the pixel is discarded.</p>
<br><hr><h2><span id='id1'><h2> Compile Our Shaders</h2><br></span></h2><p>
Now that we've made our vertex and pixel shader we can go back to our main.cpp to load this file.</p>
<br><p>
We going to be using <i>D3DCompileFromFile</i>. This takes our shader file name, the shader entry point (this is vs_main and ps_main for the vertex and pixel shader respecitvely), the shader version, and two <i>ID3DBlob</i> pointer that will point to the compiled code and the error messages from the compiler. If there aren't any errors this will be null.</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">// Create Vertex Shader</span><br>ID3DBlob* vsBlob;
<br>ID3D11VertexShader* vertexShader;
<br>{
<br><span style='white-space: pre;'>    </span>ID3DBlob* shaderCompileErrorsBlob;
<br><span style='white-space: pre;'>    </span>HRESULT hResult = <span style="color: #CD950C;">D3DCompileFromFile</span><span style="color: #A08563;">(</span><span style="color: #DAB98F;">L"shader.hlsl"</span>, nullptr, nullptr, <span style="color: #DAB98F;">"vs_main"</span>, <span style="color: #DAB98F;">"vs_5_0"</span>, <span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span>&vsBlob, &shaderCompileErrorsBlob<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">FAILED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span> {
<br><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #7D7D7D;">//NOTE: If failed output the reason why</span><br><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">const </span>char* errorString = NULL;
<br><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>hResult == <span style="color: #CD950C;">HRESULT_FROM_WIN32</span><span style="color: #A08563;">(</span>ERROR_FILE_NOT_FOUND<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span> {
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>errorString = <span style="color: #DAB98F;">"Could not compile shader; file not found"</span>;
<br><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">MessageBoxA</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>errorString, <span style="color: #DAB98F;">"Shader Compiler Error"</span>, MB_ICONERROR | MB_OK<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>} <span style="color: #CD950C;">else </span><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>shaderCompileErrorsBlob<span style="color: #A08563;">)</span> {
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>errorString <span style="color: #CD950C;">= </span><span style="color: #A08563;">(</span><span style="color: #CD950C;">const </span><span style="color: #6B8E23;">char*</span><span style="color: #A08563;">)</span><span style="color: #CD950C;">shaderCompileErrorsBlob-&gt;GetBufferPointer</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">shaderCompileErrorsBlob-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;
<br><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">MessageBoxA</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>errorString, <span style="color: #DAB98F;">"Shader Compiler Error"</span>, MB_ICONERROR | MB_OK<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>}
<br><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">return </span><span style="color: #6B8E23;">1;
</span><br><span style='white-space: pre;'>    </span>}
<br><br><span style='white-space: pre;'>    </span><span style="color: #7D7D7D;">//NOTE: Pass the compiled shader code to CreateVertexShader function</span><br><span style='white-space: pre;'>    </span>hResult = <span style="color: #CD950C;">d3d11Device-&gt;CreateVertexShader</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">vsBlob-&gt;GetBufferPointer</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>, <span style="color: #CD950C;">vsBlob-&gt;GetBufferSize</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>, nullptr, &vertexShader<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;
<br>}
<br></div><br><p>
We compile the shader and check if we got any errors. First, we check if there was an error of File Not Found. If not we check that there weren't any compiler errors. We output the errors to the user via a MessageBox. If the shader was compiled the compiled code will go into the psBlob. We then use this psBlob to create the shader using the <i>d3d11Device</i>.</p>
<br><p>
We only need the compiled shader code to create the shader. On a release game, you could save the psBlob (as it is just a string) to a file and load it on startup to avoid having to compile. This is an advantage over OpenGL which doesn't give you this option.  We compile both the vertex and pixel shader.</p>
<br><p>
We do the same for the pixel shader:</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">// Create Pixel Shader</span><br>ID3D11PixelShader* pixelShader;
<br>{
<br><span style='white-space: pre;'>    </span>ID3DBlob* psBlob;
<br><span style='white-space: pre;'>    </span>ID3DBlob* shaderCompileErrorsBlob;
<br><span style='white-space: pre;'>    </span>HRESULT hResult = <span style="color: #CD950C;">D3DCompileFromFile</span><span style="color: #A08563;">(</span><span style="color: #DAB98F;">L"shader.hlsl"</span>, nullptr, nullptr, <span style="color: #DAB98F;">"ps_main"</span>, <span style="color: #DAB98F;">"ps_5_0"</span>, <span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span>&psBlob, &shaderCompileErrorsBlob<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">FAILED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>
<br><span style='white-space: pre;'>    </span>{
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">const </span>char* errorString = NULL;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>hResult == <span style="color: #CD950C;">HRESULT_FROM_WIN32</span><span style="color: #A08563;">(</span>ERROR_FILE_NOT_FOUND<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>errorString = <span style="color: #DAB98F;">"Could not compile shader; file not found"</span>;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">else </span><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>shaderCompileErrorsBlob<span style="color: #A08563;">)</span>{
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>errorString <span style="color: #CD950C;">= </span><span style="color: #A08563;">(</span><span style="color: #CD950C;">const </span><span style="color: #6B8E23;">char*</span><span style="color: #A08563;">)</span><span style="color: #CD950C;">shaderCompileErrorsBlob-&gt;GetBufferPointer</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">shaderCompileErrorsBlob-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>}
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">MessageBoxA</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>errorString, <span style="color: #DAB98F;">"Shader Compiler Error"</span>, MB_ICONERROR | MB_OK<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #CD950C;">return </span><span style="color: #6B8E23;">1;
</span><br><span style='white-space: pre;'>    </span>}
<br><br><span style='white-space: pre;'>    </span>hResult = <span style="color: #CD950C;">d3d11Device-&gt;CreatePixelShader</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">psBlob-&gt;GetBufferPointer</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>, <span style="color: #CD950C;">psBlob-&gt;GetBufferSize</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>, nullptr, &pixelShader<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">psBlob-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;
<br>}
<br><br></div><br><p>
Notice it looks the same as creating the vertex shader. The only difference is passing <i>ps_main</i> as the entry point, and using the <i>CreatePixelShader</i> function to create the shader.</p>
<br><hr><h2><span id='id2'><h2> Create the Vertex Buffer</h2><br></span></h2><p>
Ok, we've created our shader. Next is to create our vertex buffer that will store the points that define our triangle. For this example our vertex buffer will contain the vertex position and color. It is defined as a big array of floats with the values interleaved: <i>posXposYcolorRcolorGcolorBcolorAposXposYcolorRcolorGcolorBcolorA</i>.</p>
<br><p>
Let's make our array now:</p>
<br><div class="code-block-left "><span style="color: #6B8E23;">float </span>vertexData[] = { <span style="color: #7D7D7D;">// x, y, r, g, b, a</span><br><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">0.0f, </span> <span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f,
</span><br><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f,
</span><br><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">1.f
</span><br>};
<br></div><br><p>
We're defining three vertexes, each vertex has 6 float values that define it (called the stride). When we draw this buffer, we have to tell our <i>d3dDevice</i> this information, also how many vertexes are in the buffer. The offset is how many elements in we won't to start drawing from. We will want all elements to be drawn so we will set the value at zero. So let's fill it out now:</p>
<br><div class="code-block-left ">UINT numVerts;
<br>UINT stride;
<br>UINT offset;
<br>{
<br><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">float </span>vertexData[] = { <span style="color: #7D7D7D;">// x, y, r, g, b, a</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">0.0f, </span> <span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f,
</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f,
</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">1.f
</span><br><span style='white-space: pre;'>    </span>};
<br><span style='white-space: pre;'>    </span>stride = <span style="color: #6B8E23;">6 </span>* <span style="color: #CD950C;">sizeof</span><span style="color: #A08563;">(</span>float<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span>numVerts = <span style="color: #CD950C;">sizeof</span><span style="color: #A08563;">(</span>vertexData<span style="color: #A08563;">)</span> / stride;
<br><span style='white-space: pre;'>    </span>offset = <span style="color: #6B8E23;">0;
</span><br>}
<br></div><br><p>
Now we can upload this to the GPU. First we create a <i>D3D11_BUFFER_DESC</i>, describing the buffer we want. We want be touching this data again while the program is running so we set the Usage flag <i>D3D11_USAGE_IMMUTABLE</i> (if you were making a buffer to store per instance data each frame you'd change this to <i>D3D11_USAGE_DYNAMIC</i>). This is a vertex buffer, not a index buffer or constant buffer, so we set the BindFlags to <i>D3D11_BIND_VERTEX_BUFFER</i>.</p>
<br><div class="code-block-left ">D3D11_BUFFER_DESC vertexBufferDesc = {};
<br>vertexBufferDesc.ByteWidth = <span style="color: #CD950C;">sizeof</span><span style="color: #A08563;">(</span>vertexData<span style="color: #A08563;">)</span>;
<br>vertexBufferDesc.Usage     = D3D11_USAGE_IMMUTABLE;
<br>vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
<br></div><br><p>
To create a buffer we have to wrap our vertex data in a <i>D3D11_SUBRESOURCE_DATA</i> struct. We can then use the <i>d3d11Device</i> to create a buffer.</p>
<br><div class="code-block-left ">D3D11_SUBRESOURCE_DATA vertexSubresourceData = { vertexData };
<br>ID3D11Buffer* vertexBuffer;
<br>HRESULT hResult = <span style="color: #CD950C;">d3d11Device-&gt;CreateBuffer</span><span style="color: #A08563;">(</span>&vertexBufferDesc, &vertexSubresourceData, &vertexBuffer<span style="color: #A08563;">)</span>;
<br><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;
<br></div><br><p>
The full code from this section looks like this: </p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">// Create Vertex Buffer</span><br>ID3D11Buffer* vertexBuffer;
<br>UINT numVerts;
<br>UINT stride;
<br>UINT offset;
<br>{
<br><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">float </span>vertexData[] = { <span style="color: #7D7D7D;">// x, y, u, v</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">-0.5f, </span> <span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">0.f,
</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">1.f,
</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">1.f,
</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">-0.5f, </span> <span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">0.f, </span><span style="color: #6B8E23;">0.f,
</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">0.5f, </span> <span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">0.f,
</span><br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span><span style="color: #6B8E23;">0.5f, </span><span style="color: #6B8E23;">-0.5f, </span><span style="color: #6B8E23;">1.f, </span><span style="color: #6B8E23;">1.f
</span><br><span style='white-space: pre;'>    </span>};
<br><span style='white-space: pre;'>    </span>stride = <span style="color: #6B8E23;">4 </span>* <span style="color: #CD950C;">sizeof</span><span style="color: #A08563;">(</span>float<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span>numVerts = <span style="color: #CD950C;">sizeof</span><span style="color: #A08563;">(</span>vertexData<span style="color: #A08563;">)</span> / stride;
<br><span style='white-space: pre;'>    </span>offset = <span style="color: #6B8E23;">0;
</span><br><br><span style='white-space: pre;'>    </span>D3D11_BUFFER_DESC vertexBufferDesc = {};
<br><span style='white-space: pre;'>    </span>vertexBufferDesc.ByteWidth = <span style="color: #CD950C;">sizeof</span><span style="color: #A08563;">(</span>vertexData<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span>vertexBufferDesc.Usage     = D3D11_USAGE_IMMUTABLE;
<br><span style='white-space: pre;'>    </span>vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
<br><br><span style='white-space: pre;'>    </span>D3D11_SUBRESOURCE_DATA vertexSubresourceData = { vertexData };
<br><br><span style='white-space: pre;'>    </span>HRESULT hResult = <span style="color: #CD950C;">d3d11Device-&gt;CreateBuffer</span><span style="color: #A08563;">(</span>&vertexBufferDesc, &vertexSubresourceData, &vertexBuffer<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;
<br>}
<br><br></div><br><hr><h2><span id='id3'><h2> Create the Input Layout for the Vertex Buffer</h2><br></span></h2><p>
Great! We've uploaded our vertex data, we've created our shader that will draw the vertexes, now we just need to create the ID3D11InputLayout for the buffer before we can start drawing it. This is where we link the values from the vertex buffer to the VS_Input struct we defined in our shader. Our vertex buffer doesn't know that the first 2 floats of each vertex is the position data. It just sees an array of floats. To show where the values are, the code looks like like this:</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">// Create Input Layout</span><br>ID3D11InputLayout* inputLayout;
<br>{
<br><span style='white-space: pre;'>    </span>D3D11_INPUT_ELEMENT_DESC inputElementDesc[] =
<br><span style='white-space: pre;'>    </span>{
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>{ <span style="color: #DAB98F;">"POS"</span>, <span style="color: #6B8E23;">0, </span>DXGI_FORMAT_R32G32_FLOAT, <span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span>D3D11_INPUT_PER_VERTEX_DATA, <span style="color: #6B8E23;">0 </span>},
<br><span style='white-space: pre;'>    </span><span style='white-space: pre;'>    </span>{ <span style="color: #DAB98F;">"COL"</span>, <span style="color: #6B8E23;">0, </span>DXGI_FORMAT_R32G32B32A32_FLOAT, <span style="color: #6B8E23;">0, </span>D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, <span style="color: #6B8E23;">0 </span>}
<br><span style='white-space: pre;'>    </span>};
<br><br><span style='white-space: pre;'>    </span>HRESULT hResult = <span style="color: #CD950C;">d3d11Device-&gt;CreateInputLayout</span><span style="color: #A08563;">(</span>inputElementDesc, <span style="color: #CD950C;">ARRAYSIZE</span><span style="color: #A08563;">(</span>inputElementDesc<span style="color: #A08563;">)</span>, <span style="color: #CD950C;">vsBlob-&gt;GetBufferPointer</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>, <span style="color: #CD950C;">vsBlob-&gt;GetBufferSize</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>, &inputLayout<span style="color: #A08563;">)</span>;
<br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;
<br><br><span style='white-space: pre;'>    </span><span style="color: #7D7D7D;">//NOTE: We don't need our vertex shader code anymore so we can release it</span><br><span style='white-space: pre;'>    </span><span style="color: #CD950C;">vsBlob-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;
<br>}
<br></div><br><p>
We create an <i>D3D11_INPUT_ELEMENT_DESC</i> array that will tell the GPU how to interpret the data in the vertex buffer. For each type in our VS_Input struct, we marked them with a name (eg.Â : POS ) to say which values they are in the buffer. In this case the first element is "POS" (the same name as the one we wrote in shader). It is 2 floats in the buffer so we set the type to <i>DXGI_FORMAT_R32G32_FLOAT</i>. This value is at the start of each vertex so we have no offset. The "COL" attribute however would have a 8byte offset from the start of each vertex. We can use <i>D3D11_APPEND_ALIGNED_ELEMENT</i> for convenience to define the current element directly after the previous one. We also say that this value is per vertex not per instance (Per instance is useful for creating a buffer that has instancing data in it).</p>
<br><p>
We then create the InputLayout using our d3dDevice. You'll notice we pass in the vertex shader blob which we got when we created our vertex shader. This is because it needs to make sure you've actually defined the values you intend to link up with.</p>
<br><hr><h2><span id='id4'><h2> Rendering our Triangle eachÂ frame</h2><br></span></h2><p>
Now that we've got the three things to draw a triangleâ€Š-â€Šthe shader, the vertex buffer and the Input Layout, we can now draw it.</p>
<br><p>
In our game loop we have to do a few things to get ready to render:</p>
<br><h2><span id='id5'><h2> Set the Viewport size</h2><br></span></h2><p>
First we set our viewport. This is the size of the screen we are rendering to. If we were making a multiplayer game with four players playing on the same screen, we would set the viewport to just a quarter of the window size. We want to use the whole window in our case.</p>
<br><div class="code-block-left ">D3D11_VIEWPORT viewport = { <span style="color: #6B8E23;">0.0f, </span><span style="color: #6B8E23;">0.0f, </span><span style="color: #6B8E23;">960, </span><span style="color: #6B8E23;">540, </span><span style="color: #6B8E23;">0.0f, </span><span style="color: #6B8E23;">1.0f </span>};
<br><span style="color: #CD950C;">d3d11DeviceContext-&gt;RSSetViewports</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">1, </span>&viewport<span style="color: #A08563;">)</span>;
<br></div><br><p>
We set it to the same size as our buffer in the SwapChain.  The other values of the viewport are the min and max depth for the final depth value. We set these to the default min and max range (0 and 1).</p>
<br><hr><h2><span id='id6'><h2> Set our Render Target</h2><br></span></h2><p>
We then set our render targetâ€Š-â€Šthe buffer we want to draw into. This is the equivalent of <i>glBindBuffer</i> in OpenGL. We want to render to the default backbuffer in our swapChain so we set that.</p>
<br><div class="code-block-left "><span style="color: #CD950C;">d3d11DeviceContext-&gt;OMSetRenderTargets</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">1, </span>&d3d11FrameBufferView, nullptr<span style="color: #A08563;">)</span>;
<br></div><br><p>
We can bind more than one buffer using this function, for example if doing a multi buffer visual effect like <i>bloom</i>. </p>
<br><hr><h2><span id='id7'><h2> Bind our Input Layout, Shaders and Vertex Buffer</h2><br></span></h2><p>
The next step is to now use our shaders, input layout and vertex buffer.</p>
<br><div class="code-block-left "><span style="color: #CD950C;">d3d11DeviceContext-&gt;IASetPrimitiveTopology</span><span style="color: #A08563;">(</span>D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST<span style="color: #A08563;">)</span>;
<br><span style="color: #CD950C;">d3d11DeviceContext-&gt;IASetInputLayout</span><span style="color: #A08563;">(</span>inputLayout<span style="color: #A08563;">)</span>;
<br><br><span style="color: #CD950C;">d3d11DeviceContext-&gt;VSSetShader</span><span style="color: #A08563;">(</span>vertexShader, nullptr, <span style="color: #6B8E23;">0</span><span style="color: #A08563;">)</span>;
<br><span style="color: #CD950C;">d3d11DeviceContext-&gt;PSSetShader</span><span style="color: #A08563;">(</span>pixelShader, nullptr, <span style="color: #6B8E23;">0</span><span style="color: #A08563;">)</span>;
<br><br><span style="color: #CD950C;">d3d11DeviceContext-&gt;IASetVertexBuffers</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">1, </span>&vertexBuffer, &stride, &offset<span style="color: #A08563;">)</span>;
<br><br></div><br><p>
We first set the type of primitive topology we're rendering. We're drawing triangles so we set it to a triangle list. There are other options such as a TriangleStrip which can be more performant, but we're going with a triangle list for simplicity.</p>
<br><p>
We set the InputLayout to the one we created, we also set the Vertex shader and the Pixel shader to the ones we created. You can only ever have one of each set at a time, so these will override the last value set in the Device Context.</p>
<br><p>
We then set our Vertex Buffer to the buffer containing our triangle, passing in the stride and offset that we set earlier. You can set more than one buffer at a time. This can be useful if you have one with a model and one with instancing data specific to that frame (like position, rotation and scale).</p>
<br><p>
With all this set we can now draw our buffer, passing in the number of vertexes we want to draw. We want to draw the whole buffer.</p>
<br><hr><h2><span id='id8'><h2> Submit a Draw Call to the GPU</h2><br></span></h2><p>
With all our information set about how we're going to draw the buffer, we are now ready to submit a draw call to the GPU. </p>
<br><div class="code-block-left "><span style="color: #CD950C;">d3d11DeviceContext-&gt;Draw</span><span style="color: #A08563;">(</span>numVerts, <span style="color: #6B8E23;">0</span><span style="color: #A08563;">)</span>;
<br></div><br><hr><h2><span id='id9'><h2> Add the d3dCompiler header and link</h2><br></span></h2><p>
That's it! That's all the code we need to write to render the triangle. We'll now compile it. We have to add an extra header for the shader compiler and linker flag.</p>
<br><div class="code-block-left "><span style="color: #DAB98F;">#include </span>&lt;d3dcompiler.h&gt;
<br></div><br><p>
And our build script will look like this:</p>
<br><div class="code-block-left "><span style="color: #DAB98F;">cl </span>main.cpp <span style="color: #DAB98F;">/link </span>user32.lib d3d11.lib d3dcompiler.lib
<br></div><br><h2><span id='id10'><h2> Conclusion</h2><br></span></h2><p>
If we run this now and run our program we should see our colorful triangle. The colors at each vertexâ€Š-â€Šgreen, blue and red getting interpolated across the face.</p>
<br><p>
<img src='./photos/directX_lesson1_pictures/triangle.png' style='width: 60%;'></p>
<br><a target='_blank' href='https://github.com/Olster1/directX11_tutorial/blob/main/lesson3/main.cpp'><div style='background-color: #FFE5B4; border-radius: 0.5cm; padding: 0.5cm;'> You can see the full code here ðŸ‘†</div></a><br><br><p>
Pat yourself on your back. It's no small feat rendering a triangle and is the cornerstone to rendering more complicated 3d scenes. Well Done!</p>
<br><hr><div class='email-list'><p>Sign up to my Newsletter to get a weekly email about what Iâ€™m up to, what Iâ€™m learning and what Iâ€™m teaching.</p><div style='text-align: center;'><input class='email-input-style' id='email_input' type='email'/><button class='subscribe-btn' onclick='testEmail()'>Subscribe</button><div id='email-loading-progress'></div></div></div><br><hr><h2><span id='id11'><h2> Quiz</h2><br></span></h2><p>
<b>1. What two shaders are run on the GPU to render a triangle?Â </b></p>
<br><p>
[A vertex shader and a pixel shader]</p>
<br><p>
<b>2. What does the vertex shader do?Â </b></p>
<br><p>
[Turns the incoming position into a 4d vector in clip space]</p>
<br><p>
<b>3. What is the pixel shader in charge of doing?Â </b></p>
<br><p>
[Calculating the color of the pixel.]</p>
<br><p>
<b>4. What do you need to specify after the variables in the VS_Input struct?</b></p>
<br><p>
[Names that you can reference when creating the Input Layout for the buffer that will use the shader]</p>
<br><p>
<b>5. Why is the markup name SV_POSITION in the VS_OUTPUT important?Â </b></p>
<br><p>
[The VS_Output struct must have this to know which variable in the output represents the vertex position.]</p>
<br><p>
<b>6. What four things do we create before we enter our game loop to render the triangle?Â </b></p>
<br><p>
[Vertex Shader, Pixel Shader, VertexBuffer and InputLayout]</p>
<br><p>
<b>7. Can you draw multiple buffers at once?Â </b></p>
<br><p>
[Yes, IASetVertexBuffers takes in an array of buffers that will be drawn at once]</p>
<br><p>
<b>8. Can you only have one vertex and one pixel shader set at once?Â </b></p>
<br><p>
[Yes]</p>
<br><p>
<b>9. How do we draw our vertex buffer?Â </b></p>
<br><p>
[d3dDeviceContext->Draw()]</p>
<br><hr><a href='./direct3d_11_part2.html'><div style='background-color: #ccff66; border-radius: 0.5cm; padding: 0.5cm;'> PREVIOUS LESSON ðŸ‘†</div></a><br><br><a href='./direct3d_11_part4.html'><div style='background-color: #ccff66; border-radius: 0.5cm; padding: 0.5cm;'> NEXT LESSON ðŸ‘†</div></a><br><br></div>
</div>
</div>
<br><br></div></body></html><script src='email.js'></script>