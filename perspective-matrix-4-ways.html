<!DOCTYPE html>	<html lang="en">		<head>		  <title>Oliver Marsh</title>		  <meta charset="utf-8">		  <meta name="viewport" content="width=device-width, initial-scale=1">		  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">		  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">		  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>		  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>		  <link rel="stylesheet" type="text/css" href="style.css">		</head><nav class="navbar navbar-default" style="background-color: white; color: #f5f6f7;">	  <div class="container">	    <div class="navbar-header">	      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">	        <span class="icon-bar"></span>	        <span class="icon-bar"></span>	        <span class="icon-bar"></span>	      </button>	      <a class="navbar-left" href="./index.html#"><img style="width: 7cm;" src="./photos/logo2.svg"></a>	    </div>	    <div class="collapse navbar-collapse" id="myNavbar">	      <ul class="nav navbar-nav navbar-right"  style="margin-top: 25px;">	        <li><a href="./index.html">Articles</a></li>	      	<li><a href="./index.html">Games</a></li>	      	<li><a href="./about.html">About</a></li>	      </ul>	    </div>	  </div>	</nav>	<body>	<div class="container"><div class="row">
<div class="col-sm-10 col-md-12 col-lg-12">
<div class="info-card">
<h1>OpenGL and Direct3D Perspective Matrix</h1><h2>Perspective Matrix Four Ways</h2><br></div>
</div>
</div>
<div class="row">
<div class="col-sm-10 col-md-12 col-lg-12">
<div class="info-card">
<hr><p>
The Perspective Matrix is vital to 3d graphics. It's the final matrix responisble for projecting a 3d object from the world onto a flat screen. Unlike the other two common matrices used in 3d graphics: the Model Matrix (resposible for moving the vertices from Model to World Space) and View Matrix (responsible for moving the vertices from World to Camera Space), the perspective matrix can be hard to intuitively understand. Specifically the the Z-Axis transofrmation to prepare it correctly for the z-divide.</p>
<br><p>
Adding to this is the different orientations of the axis used in the 3d game world. There are two common orientations - the so called left hand and right hand coorindate orientations. The positive X axis pointing right, the positive Y axis pointing up but the positive Z-axis pointing into the screen (Left handed) or the positive Z-axis pointing out of the screen (Right Handed coordinate system). Although these are the two most common coordinate systems there are 4 possible unique 3d orientations that a game world could use. This means 4 different perspective matrices to map the game world onto a flat screen. This is only for one graphics API. The number of matrices increase by the number of graphics API's with their own internal coordinate systems (NDC space) that you have to convert to.</p>
<br><p>
In OpenGL NDC space, the coordinate system is Left-Handed (the z axis pointing into the screen). Direct3D is the same, but the Z-Axis origin is in a different place. In Opengl the Z-Axis ranges from -1 to 1, in Direct3D the Z-Axis ranges from 0 to 1 (both pointing into the screen). </p>
<br><p>
On top of this, there is one more thing to take into consideration that also affects the perspective matrix: the way the matrix multiplication function is defined in the GPU shader language. How the shader language expects the matrix to be laid out in memory: Row Major or Colum Major. </p>
<br><hr><h2>Contents</h2><br><h4><a href='#id0'> Three factors we have to take into account</a></h4><br><h4><a href='#id1'> 4x4 Matrix Struct defined in code</a></h4><br><h4><a href='#id2'> Same Code for all the Perspective Matrices</a></h4><br><h4><a href='#id3'> Matrix 1</a></h4><br><h4><a href='#id4'> Matrix 2</a></h4><br><h4><a href='#id5'> Matrix 3</a></h4><br><h4><a href='#id6'> Matrix 4</a></h4><br><h4><a href='#id7'> Orthographic Matrices</a></h4><br><h4><a href='#id8'> Same Code for all the Orthographic Matrices</a></h4><br><h4><a href='#id9'> Matrix 5</a></h4><br><h4><a href='#id10'> Change the X Y origin of window </a></h4><br><h4><a href='#id11'> Matrix 6</a></h4><br><h4><a href='#id12'> Matrix 7</a></h4><br><h4><a href='#id13'> Matrix 8</a></h4><br><h4><a href='#id15'> Notes</a></h4><br><hr><h2><span id='id0'><h2> Three factors we have to take into account</h2><br></span></h2><p>
So there are three factors that contribute to the possible perspective matrices you could have: </p>
<br><p>
1. The coordinate system orientation of the Game World.</p>
<br><p>
2. The coordinate system of the GPU API your're using (NDC Space)</p>
<br><p>
3. The way the GPU API interprets the memory layout of the matrix in the shader language (is is Row Major or Column Major?). </p>
<br><p>
So to build the right perspective matrix, you have to be aware of all three of these things. For simplicity I'll only be looking at left and right handed game world coordinate systems (the two most common ones) and the two graphics APIs: OpenGL and Direct3D. I won't be deriving the matrix, just showing you the matrix and how you'd define it in code so you can see the differences. </p>
<br><hr><h2><span id='id1'><h2> 4x4 Matrix Struct defined in code </h2><br></span></h2><p>
Our matrix struct will look like this: </p>
<br><div class="code-block-left "><span style="color: #CD950C;">struct </span>Matrix_4x4 {<br><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">float </span>E[16];<br>};<br></div><br><p>
Just 16 floats side by side in memory. Our job is to fill the right values in. </p>
<br><hr><h2><span id='id2'><h2> Same Code for all the Perspective Matrices</h2><br></span></h2><p>
All the perspective matrices will be using the same data to build the matrix. </p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">//NOTE: The Field of View the camera can see in degrees</span><br><span style="color: #6B8E23;">float </span>FOV_degrees = <span style="color: #6B8E23;">60.0f;</span><br><br><span style="color: #7D7D7D;">//NOTE: Our Near and Far plane constants</span><br><span style="color: #6B8E23;">float </span>nearClip = <span style="color: #6B8E23;">0.1f;</span><br><span style="color: #6B8E23;">float </span>farClip = <span style="color: #6B8E23;">1000.0f;</span><br><br><span style="color: #7D7D7D;">//NOTE: Convert the Camera's Field of View from Degress to Radians</span><br><span style="color: #6B8E23;">float </span>FOV_radians <span style="color: #CD950C;">= </span><span style="color: #A08563;">(</span>FOV_degrees*PI32<span style="color: #A08563;">)</span> / <span style="color: #6B8E23;">180.0f;</span><br><br><span style="color: #7D7D7D;">//NOTE: Get the size of the plane the game world will be projected on.</span><br><span style="color: #6B8E23;">float </span>t = <span style="color: #CD950C;">tan</span><span style="color: #A08563;">(</span>FOV_radians/2<span style="color: #A08563;">)</span>; <span style="color: #7D7D7D;">//plane's height</span><br><span style="color: #6B8E23;">float </span>r = t*aspectRatio; <span style="color: #7D7D7D;">//plane's width</span><br><br></div><br><p>
We have the Near and Far clip plane constants that may be something like 0.1 and 1000 respectively. This defines the min and max bounds of what is visible on the Z-Axis.</p>
<br><p>
We then have the Field of View (FOV) of the camera in the game world. It is how much of the world in the X and Y axis the camera can see at once. We convert it to radians. </p>
<br><p>
We divide the FOV by 2 since the FOV is the angle for the whole camera view (the whole viewport) but we just want half since the x,y origin is in the middle of the screen. The FOV is assumed for what the camera can see in the Y-Axis. We use the aspect ratio of the viewport to get the size of the projection plane in the X-Axis. (You could just as easily have the field of view be defined as what the X-Axis can see and use the aspect ratio to get the Y-Axis size).</p>
<br><div style='background-color: #FFE5B4; border-radius: 0.5cm; padding: 0.5cm;'> The near and clip plane <b>aren't</b> negated based on the whether the game axis orientation is left handed or right handed. <b>They are always positive.</b>  </div><hr><h2><span id='id3'><h2> Matrix 1: OpenGL for Left Handed Orientated Game World (Camera looking down the Positive Z-Axis)</h2><br></span></h2><div class="code-block-left ">Matrix_4x4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">1 </span>/ r,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">1 </span>/ t,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span><span style="color: #CD950C;"> </span><span style="color: #A08563;">(</span>farClip + nearClip<span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>,  <span style="color: #6B8E23;">1, </span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span><span style="color: #CD950C;"> </span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">-2*nearClip*farClip</span><span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>,  <span style="color: #6B8E23;">0</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
You'll notice it has the 1 in the 4th column, 3rd row which allows for the divide by Z the graphics card will do for us that makes the world have perspective (as opposed to orthographic). The 1 is positive since the Z-Axis in the game world is the same direction as the Z-Axis in OpenGl's NDC space (positive Z going into the screen).</p>
<br><p>
The values are also loaded into memory so that they are interleaved like so (moving left to right, top to down):</p>
<br><div class="code-block-left ">XAxis.x XAxis.y XAxis.z XAxis.w YAxis.x YAxis.y YAxis.z YAxis.w <br>ZAxis.x ZAxis.y ZAxis.z ZAxis.w WAxis.x WAxis.y WAxis.z WAxis.w<br><br></div><br><p>
This is how the Opengl shader langauge expects the memory to be laid out for it's matrix multiplication. </p>
<br><hr><h2><span id='id4'><h2> Matrix 2: OpenGL for Right Handed Orientated Game World (Camera looking down the Negative Z-Axis)</h2><br></span></h2><div class="code-block-left ">Matrix_4x4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">1 </span>/ r,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">1 </span>/ t,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #CD950C;">-</span><span style="color: #A08563;">(</span><span style="color: #A08563;">(</span>farClip + nearClip<span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>,  <span style="color: #6B8E23;">-1, </span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span><span style="color: #CD950C;"> </span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">-2*nearClip*farClip</span><span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>,  <span style="color: #6B8E23;">0</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
You'll notice the 1 value in the 4th column, 3rd row is now negative. Also the Z-component of the matrix (3rd Column, 3rd Row) is also negative now too. This is in order to flip the Z-Axis. You can't just have the z-component (3rd Column, 3rd Row) negative since then the homogenous value of the resulting vector (w component) would be neagtive and we would divide the X and Y by a negative value, flipping them aswell. So we want to the 1 value in the 4th column, 3rd row to also be negative.</p>
<br><hr><h2><span id='id5'><h2> Matrix 3: Direct3D for Left Handed Orientated Game World (Camera looking down the Positive Z-Axis)</h2><br></span></h2><div class="code-block-left ">Matrix_4x4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">1 </span>/ r,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">1 </span>/ t,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #CD950C;">farClip/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>, <span style="color: #CD950C;"> </span><span style="color: #A08563;">(</span>-nearClip*farClip<span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>, <br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">1, </span> <span style="color: #6B8E23;">0</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
For the Direct3D matrices we have to account for two things: the memory layout of the matrix is swapped to what is used with Opengl: it is the transpose of the OpenGL matrix. Also the origin of the Z-Axis in NDC space is at zero not negative one. </p>
<br><p>
To account for the memory layout, you'll see the matrix is the transpose of the OpenGL one: the perspective value of <b>1</b> is in 3rd column, 4th row now. And to account for the NDC origin, we no longer multiply the Z-Translation component(3rd Row, 4th Column) by 2 and the Z-Component(3rd Row, 3rd Column) value has also changed.</p>
<br><p>
The memory layout the Direct3D expects (moving left to right, top to down):</p>
<br><div class="code-block-left ">XAxis.x YAxis.x ZAxis.x WAxis.x XAxis.y YAxis.y ZAxis.y WAxis.y<br>XAxis.z YAxis.z ZAxis.z WAxis.z XAxis.w YAxis.w ZAxis.w WAxis.w<br><br></div><br><hr><h2><span id='id6'><h2> Matrix 4: Direct3D for Right Handed Orientated Game World (Camera looking down the Negative Z-Axis)</h2><br></span></h2><div class="code-block-left ">Matrix_4x4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">1 </span>/ r,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">1 </span>/ t,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #CD950C;">-farClip/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>-nearClip*farClip<span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>, <br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">-1, </span> <span style="color: #6B8E23;">0</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
We've now added in the negative values to flip the positive Z-axis from pointing out of the screen to into the screen (Same as what we did with the OpenGL matrix).</p>
<br><hr><p>
That's it. The four most common perspective matrices you'll come across in game programming. It should be noted that these matrices assume the <i>near clip plane</i> is also the distance of the projection plane from the camera's eye. This doesn't have to be the case: the distance of the plane can be decoupled from the <i>near clip plane</i>, although this is less common and doesn't hold any significant advantages.</p>
<br><hr><h2><span id='id7'><h2> Orthographic Matrices</h2><br></span></h2><p>
Above are all perspective matrices where all the light rays are coming into a single point: the centre of the camera. The other type of matrix you'll come across in graphics programming is the <b>Orthographic Matrix</b> where all the light rays hiting the camera are parallel to each other . This is handy for doing GUI programming, game UI or making a program like a text editor that doesn't need perspective. Just like there are 4 perspective matrices to account for the two game world orientations and two Graphics APIs, there are also 4 Orthographics matrices for the same cases. I'll outline them now.</p>
<br><hr><h2><span id='id8'><h2> Same Code for all the Orthographic Matrices</h2><br></span></h2><div class="code-block-left "><span style="color: #7D7D7D;">//NOTE: The size of the plane we're projection onto</span><br><span style="color: #6B8E23;">float </span>a = <span style="color: #6B8E23;">2.0f </span>/ screenWidth; <br><span style="color: #6B8E23;">float </span>b = <span style="color: #6B8E23;">2.0f </span>/ screenHeight;<br><br><span style="color: #7D7D7D;">//NOTE: Near and Far Clip plane</span><br><span style="color: #6B8E23;">float </span>nearClip = <span style="color: #6B8E23;">0.1f;</span><br><span style="color: #6B8E23;">float </span>farClip = <span style="color: #6B8E23;">1000.0f;</span><br><br><span style="color: #7D7D7D;">//NOTE: We can offset the origin of the viewport by adding these to the translation part of the matrix</span><br><span style="color: #6B8E23;">float </span>originOffsetX = <span style="color: #6B8E23;">0; </span><span style="color: #7D7D7D;">//NOTE: Defined in NDC space</span><br><span style="color: #6B8E23;">float </span>originOffsetY = <span style="color: #6B8E23;">0; </span><span style="color: #7D7D7D;">//NOTE: Defined in NDC space</span><br><br></div><br><div style='background-color: #FFE5B4; border-radius: 0.5cm; padding: 0.5cm;'> The near and clip plane <b>aren't</b> negated based on the whether the left handed or right handed coordinate system is being used. <b>They are always positive.</b>  </div><hr><h2><span id='id9'><h2> Matrix 5: OpenGL Orthographic Matrix For Left Handed Orientation (Positive Z-Axis into the screen) </h2><br></span></h2><div class="code-block-left ">Matrix4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span>a,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> b,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span><span style="color: #CD950C;"> </span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">2.0f</span><span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>, <span style="color: #6B8E23;">0, </span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span>originOffsetX, originOffsetY, <span style="color: #CD950C;">-</span><span style="color: #A08563;">(</span><span style="color: #A08563;">(</span>farClip + nearClip<span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>,  <span style="color: #6B8E23;">1</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
You'll see the homgenous cooridinate value (4th column, 3rd row) is now zero. Since we don't want to divide by the z-coordinate with a orthographic projection, we want the resulting w coordinate to be a 1. So we put a 1 in the 4th column, 4th row. (If we didn't do this, the w component of the resulting vector would be zero, and the graphics card would try diving the x, y, z values by zero which is not good!).</p>
<br><hr><h2><span id='id10'><h2> Change the X Y origin of window </h2><br></span></h2><p>
We also have the ability to change where we want the origin of the incoming vertices to be. This is handy if we want to render as if the bottom-left corner of the window is origin. To do that we would change the origin offset values:</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">//NOTE: Change the origin to the bottom-left corner of our Viewport</span><br><span style="color: #6B8E23;">float </span>originOffsetX = <span style="color: #6B8E23;">-1; </span><span style="color: #7D7D7D;">//NOTE: Defined in NDC space</span><br><span style="color: #6B8E23;">float </span>originOffsetY = <span style="color: #6B8E23;">-1; </span><span style="color: #7D7D7D;">//NOTE: Defined in NDC space</span><br></div><br><p>
We could also move the origin of the window to the top-left hand corner which might be handy for text rendering:</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">//NOTE: Change the origin to the top-left corner of our Viewport</span><br><span style="color: #6B8E23;">float </span>originOffsetX = <span style="color: #6B8E23;">-1; </span><span style="color: #7D7D7D;">//NOTE: Defined in NDC space</span><br><span style="color: #6B8E23;">float </span>originOffsetY = <span style="color: #6B8E23;">1; </span><span style="color: #7D7D7D;">//NOTE: Defined in NDC space</span><br></div><br><hr><h2><span id='id11'><h2> Matrix 6: OpenGL Orthographic Matrix For Right Handed Orientation (Negative Z-Axis into the screen) </h2><br></span></h2><div class="code-block-left ">Matrix4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span>a,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> b,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0,</span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #CD950C;">-</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">2.0f</span><span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>, <span style="color: #6B8E23;">0, </span><br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span>originOffsetX, originOffsetY, <span style="color: #CD950C;">-</span><span style="color: #A08563;">(</span><span style="color: #A08563;">(</span>farClip + nearClip<span style="color: #A08563;">)</span><span style="color: #CD950C;">/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>,  <span style="color: #6B8E23;">1</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
The only difference in this Right Handed Orientation is the negative sign on the Z-component of the matrix (3rd Column, 3rd Row), flipping the incoming z values. We don't have to negate the 1 value in the far right column like in the perspective version, since this time the w component of the resulting vector won't have the incoming z value, it will just stay 1.   </p>
<br><hr><h2><span id='id12'><h2> Matrix 7: Direct3D Orthographic Matrix For Left Handed Orientation (Positive Z-Axis into the screen) </h2><br></span></h2><div class="code-block-left ">Matrix4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span>a,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> originOffsetX,<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> b,  <span style="color: #6B8E23;">0, </span> originOffsetY,<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #CD950C;">1.0f/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>, <span style="color: #CD950C;">nearClip/</span><span style="color: #A08563;">(</span>nearClip - farClip<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>, <br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">1</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
We account for the origin shift in Direct3D and the memory layout difference. </p>
<br><hr><h2><span id='id13'><h2> Matrix 8: Direct3D Orthographic Matrix For Right Handed Orientation (Negative Z-Axis into the screen) </h2><br></span></h2><div class="code-block-left ">Matrix4 result = {{<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span>a,  <span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> originOffsetX,<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> b,  <span style="color: #6B8E23;">0, </span> originOffsetY,<br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">0, </span> <span style="color: #CD950C;">-1.0f/</span><span style="color: #A08563;">(</span>farClip - nearClip<span style="color: #A08563;">)</span>, <span style="color: #CD950C;">nearClip/</span><span style="color: #A08563;">(</span>nearClip - farClip<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>, <br><span style='padding: 0.5cm;'></span><span style='padding: 0.5cm;'></span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span> <span style="color: #6B8E23;">1</span><br><span style='padding: 0.5cm;'></span>}};<br><br></div><br><p>
Same as above but we flip the incoming z values. </p>
<br><hr><h2><span id='id14'><h2> Conclusion </h2><br></span></h2><p>
Hopefully this wil be a handy reference when implementing the perspective matrix in your program. We covered the four most common perspective matrices you'll come across aswell as showing the orthographic versions. </p>
<br><hr><h2><span id='id15'><h2> Notes</h2><br></span></h2><p>
[1] These matrices and information is taken from <i>3D Math Primer for Graphics and Game Development (2nd Edition) by Fletcher Dunn and Ian Parberry</i> in Chapter 10</p>
<br><p>
[2] <a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix'>You can see the derivation of the perspective matrix here</a>. This is building a matrix like Matrix 4 in the article.</p>
<br></div>
</div>
</div>
<br><br></div></body></html><script src='email.js'></script>