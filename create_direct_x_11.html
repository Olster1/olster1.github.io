<!DOCTYPE html>	<html lang="en">		<head>		  <title>Oliver Marsh</title>		  <meta charset="utf-8">		  <meta name="viewport" content="width=device-width, initial-scale=1">		  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">		  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">		  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>		  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>		  <link rel="stylesheet" type="text/css" href="style.css">		</head><nav class="navbar navbar-default" style="background-color: white; color: #f5f6f7;">	  <div class="container">	    <div class="navbar-header">	      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">	        <span class="icon-bar"></span>	        <span class="icon-bar"></span>	        <span class="icon-bar"></span>	      </button>	      <a class="navbar-left" href="./index.html#"><img style="width: 7cm;" src="./photos/logo2.svg"></a>	    </div>	    <div class="collapse navbar-collapse" id="myNavbar">	      <ul class="nav navbar-nav navbar-right"  style="margin-top: 25px;">	        <li><a href="./index.html">Direct X</a></li>	      	<li><a href="./index.html">Games</a></li>	      	<li><a href="./about.html">About</a></li>	      </ul>	    </div>	  </div>	</nav>	<body>	<div class="container"><div class="row">
<div class="col-sm-10 col-md-12 col-lg-12">
<div class="info-card">
<h1>Using DirectX 11 for games: Part 1</h1></div>
</div>
</div>
<div class="row">
<div class="col-sm-10 col-md-12 col-lg-12">
<div class="info-card">
<a target='_blank' href='https://github.com/kevinmoran/BeginnerDirect3D11'> This series is based on Kevin Moran's great DirectX tutorial code which you can get here üëÜ</a><br><br><p>
In this article, I‚Äôm going to walk through creating a DirectX 11 context to use with your games. DirectX 11 is the native graphics API for Windows. DirectX has advantages over OpenGL in that it is more reliable on Windows computers ‚Äî this is an advantage when it comes time to ship your game. You want it to work on as many machines as possible with the least hiccups. You don‚Äôt want half your users (or worse!) to load your game up and find a blank screen. The other advantage over OpenGL is that DirectX is a lot easier to reason about. OpenGL is a giant state machine where you bind textures, vertex arrays, and options like blend modes which stay bound until you specifically unbind them or unset them. This can lead to bugs that can be hard to find. DirectX 11 API is less of a state machine, and more function calls that you can reason, making the experience of graphics program more enjoyable.</p>
<br><hr><h3>Our Entry Point</h3><br><br><p>
Let's get started! The first thing for any Windows program is the windows entry point which we‚Äôre going to stick into a main.cpp file:</p>
<br><div class="code-block-left ">include &lt;windows.h&gt;<br><span style="color: #6B8E23;">int </span>WINAPI <span style="color: #CD950C;">WinMain</span><span style="color: #A08563;">(</span>HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPSTR /*lpCmdLine*/, <span style="color: #6B8E23;">int </span>/*nShowCmd*/<span style="color: #A08563;">)</span> {<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">return </span><span style="color: #6B8E23;">0;</span><br>}<br></div><br><p>
We‚Äôve commented out the variables we don‚Äôt use in our program ‚Äî we only use the first variable of the function, the hInstance ‚Äî this is the instance of our exe running, which we‚Äôre going to need to create a window.</p>
<br><p>
We can compile this to make sure everything is working. We‚Äôre using the MSVC compiler from the command line so we‚Äôre going to type:</p>
<br><div class="code-block-left ">cl main.cpp<br></div><br><p>
Great! Hopefully, there aren‚Äôt any compiler errors. Next, we‚Äôre going to declare a window class. This is something you create to choose the settings for the window we want to create. It looks something like this:</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">//First register the type of window we are going to create</span><br>WNDCLASSEXW winClass = {};<br>winClass.cbSize = <span style="color: #CD950C;">sizeof</span><span style="color: #A08563;">(</span>WNDCLASSEXW<span style="color: #A08563;">)</span>;<br>winClass.style = CS_HREDRAW | CS_VREDRAW;<br>winClass.lpfnWndProc = &WndProc;<br>winClass.hInstance = hInstance;<br>winClass.hIcon = <span style="color: #CD950C;">LoadIconW</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>IDI_APPLICATION<span style="color: #A08563;">)</span>;<br>winClass.hCursor = <span style="color: #CD950C;">LoadCursorW</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>IDC_ARROW<span style="color: #A08563;">)</span>;<br>winClass.lpszClassName = L"MyWindowClass";<br>winClass.hIconSm = <span style="color: #CD950C;">LoadIconW</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>IDI_APPLICATION<span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">!RegisterClassExW</span><span style="color: #A08563;">(</span>&winClass<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span> {<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">MessageBoxA</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>"RegisterClassEx failed", "Fatal Error", MB_OK<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">return </span><span style="color: #CD950C;">GetLastError</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>}<br></div><br><p>
We declare a struct call winClass of type WINDCLASSEXW. Notice we‚Äôre using the W versions of the WinAPI functions. There is also the A type. The difference is that the W type support Unicode strings (W meaning wide characters or 2 bytes per character), whereas the A type only support ANSI characters (non unicode, with only 1 byte per character). So to be more up to date we‚Äôre using the W functions. There are two other things we‚Äôll add to support unicode:</p>
<br><p>
1. Put the define unicode at the top of our file. This tells other windows functions we‚Äôre supporting unicode so please help us.</p>
<br><p>
2. Put L before a string literal. This tells the compiler to treat the string as a wide string (2 bytes per character). This looks like this L‚ÄùMyWindowClass‚Äù.</p>
<br><a target='_blank' href='http://www.cplusplus.com/forum/articles/16820/'> You can read more about Unicode support on windows here üëÜ</a><br><br><p>
The main thing to notice here is that we want a window that redraws when it is resized. We do this by passing the flags <i>CS_HREDRAW | CS_VREDRAW</i>. We‚Äôre also passing a pointer to a function called WndProc seen in the line <i>winClass.lpfnWndProc = &WndProc;</i></p>
<br><p>
<img src='./photos/directX_lesson1_pictures/directx03.png' style='width: 60%;'></p>
<br><p>
This is the callback that handles events sent to our app like resizing, keyboard input, and exiting our program. We have to define it ourselves, so we‚Äôll do that above our main function.</p>
<br><div class="code-block-left ">LRESULT CALLBACK <span style="color: #CD950C;">WndProc</span><span style="color: #A08563;">(</span>HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam<span style="color: #A08563;">)</span> {<br>&emsp;&emsp;&emsp;&emsp;LRESULT result = <span style="color: #6B8E23;">0;</span><br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">switch</span><span style="color: #A08563;">(</span>msg<span style="color: #A08563;">)</span> {<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;case WM_KEYDOWN: {<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>wparam == VK_ESCAPE<span style="color: #A08563;">)</span><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">PostQuitMessage</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;break;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;case WM_DESTROY: {<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">PostQuitMessage</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;} break;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;default:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;result = <span style="color: #CD950C;">DefWindowProcW</span><span style="color: #A08563;">(</span>hwnd, msg, wparam, lparam<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;}<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">return </span>result;<br>}<br></div><br><p>
You‚Äôll see that we‚Äôre handling the WM_KEYDOWN event in which we check if the key is escape. If so we destroy our window. We also handle the WM_DESTROY event, which we post a QuitMessage which we‚Äôll handle in our message loop. All other events we give to the default function.</p>
<br><p>
Next we‚Äôll actually create our window.</p>
<br><p>
<img src='./photos/directX_lesson1_pictures/directx01.png' style='width: 50vw;'></p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">//Now create the actual window</span><br>RECT initialRect = { <span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">960, </span><span style="color: #6B8E23;">540 </span>};<br><span style="color: #CD950C;">AdjustWindowRectEx</span><span style="color: #A08563;">(</span>&initialRect, WS_OVERLAPPEDWINDOW, FALSE, WS_EX_OVERLAPPEDWINDOW<span style="color: #A08563;">)</span>;<br>LONG initialWidth = initialRect.right - initialRect.left;<br>LONG initialHeight = initialRect.bottom - initialRect.top;<br><br>HWND hwnd = <span style="color: #CD950C;">CreateWindowExW</span><span style="color: #A08563;">(</span>WS_EX_OVERLAPPEDWINDOW,<br>winClass.lpszClassName,<br>L"Direct X Window - not yet",<br>WS_OVERLAPPEDWINDOW | WS_VISIBLE,<br>CW_USEDEFAULT, CW_USEDEFAULT,<br>initialWidth, <br>initialHeight,<br><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span>hInstance, <span style="color: #6B8E23;">0</span><span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>!hwnd<span style="color: #A08563;">)</span> {<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">MessageBoxA</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>"CreateWindowEx failed", "Fatal Error", MB_OK<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">return </span><span style="color: #CD950C;">GetLastError</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>}<br></div><br><p>
We use the CreateWindowExW to actually create our window. We give it the windowclass we created before and give the window a name. We also are passing our hInstance (the handle to our exe) and some initial flags ‚Äî WS_OVERLAPPEDWINDOW | WS_VISIBLE (we want a normal window type and we want our window to be visible). We also pass the initial size of our window. There is something to note here ‚Äî the initial width & height of the window include the border, to get the actually inner dimension to be what we want we have to use</p>
<br><div class="code-block-left "><span style="color: #CD950C;">AdjustWindowRectEx</span><span style="color: #A08563;">(</span>&initialRect, WS_OVERLAPPEDWINDOW, FALSE, WS_EX_OVERLAPPEDWINDOW<span style="color: #A08563;">)</span>;<br></div><br><p>
We pass in the dimensions we want for our inner window, and it gives back the dimensions including the border that we should pass to CreateWindow.</p>
<br><p>
<img src='./photos/directX_lesson1_pictures/directx02.png' style='width: 50vw;'></p>
<br><p>
Great! If we compile this now we should see a window briefly appear then disappear again. Let‚Äôs do that.</p>
<br><p>
To compile is now we need to pass a linker flag since we‚Äôre using functions that live in <i>user32.lib</i></p>
<br><div class="code-block-left ">cl main.cpp /link user32.lib<br></div><br><p>
Now when we run this and run our main.exe, we should see our window briefly appear. To finish this lesson of we‚Äôre going to add the infamous game loop.</p>
<br><hr><h3>The Game Loop</h3><br><br><p>
<img src='./photos/directX_lesson1_pictures/directx04.png' style='width: 50vw;'></p>
<br><p>
Below our CreateWindow function, we‚Äôll write this:</p>
<br><div class="code-block-left "><span style="color: #6B8E23;">bool </span>running = true;<br><span style="color: #CD950C;">while</span><span style="color: #A08563;">(</span>running<span style="color: #A08563;">)</span> {<br>}<br></div><br><p>
If we ran this we‚Äôd be stuck in an infinite loop since we don‚Äôt handle our messages ‚Äî specifically our exit message. This is where our WndProc callback is handled to process the events we received. We are going to use PeekMessage instead of GetMessage to receive our events. The difference is that GetMessage stays waiting for messages to process, instead of continuing on with the program. For a game you want PeekMessage.</p>
<br><div class="code-block-left "><span style="color: #6B8E23;">bool </span>running = true;<br><span style="color: #CD950C;">while</span><span style="color: #A08563;">(</span>running<span style="color: #A08563;">)</span> {<br>&emsp;&emsp;&emsp;&emsp;MSG msg = {};<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">while</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">PeekMessageW</span><span style="color: #A08563;">(</span>&msg, <span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span>PM_REMOVE<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span><br>&emsp;&emsp;&emsp;&emsp;{<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>msg.message == WM_QUIT<span style="color: #A08563;">)</span><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;isRunning = false;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">TranslateMessage</span><span style="color: #A08563;">(</span>&msg<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">DispatchMessageW</span><span style="color: #A08563;">(</span>&msg<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;}<br>}<br></div><br><p>
Our WndProc callback is called via DispatchMessage. So all input is processed there. You‚Äôll see we handle the WM_QUIT message here by setting running to false. This is when we press the Red X button or we press escape because we handle this in our wndProc callback.</p>
<br><p>
Now if we compile it using the same code as above (cl main.cpp /link user32.lib) and run it, we‚Äôll get a window that stays open. We can quit it by pressing the Red X or pressing escape.</p>
<br><p>
Awesome! Well done. We‚Äôre on our way to getting a directX renderer going.</p>
<br><a target='_blank' href='https://github.com/Olster1/directX11_tutorial/blob/main/lesson1/main.cpp'> You can see all the code up to this point here üëÜ</a><br><br><hr><h2>Start using DirectX </h2><br><p>
Ok next we‚Äôre actually going to jump into using DirectX. First we need to include the directX header file at the top of our main.cpp file.</p>
<br><div class="code-block-left ">include &lt;d3d11_1.h&gt;<br></div><br><p>
First we‚Äôre going to create two things ‚Äî a d3d11device and a d3d11DeviceContext. When we create a device, we‚Äôre specifying what type of d3d features we want (just d3d11, or d3d9 and d3d10 aswell?), whether we want software or hardware (using the GPU) rendering? And what type of pixel format do we want to support?</p>
<br><p>
<img src='./photos/directX_lesson1_pictures/directx1.png' style='width: 60%;'></p>
<br><p>
The device is in charge of creating resources (like shaders, frame buffers, and vertex buffers)and talking to the video adapter. You only want to create one device per program.</p>
<br><p>
A device context on the other hand contains the circumstances or setting in which the device is used. It‚Äôs specifically used to generate render commands using the resources owned by the device. We use the d3ddevice to create resources like shaders, vertex buffers, textures & framebuffers. And we use the device context to set the render states like setViewport, setShader, setVertexBuffers and submit draw calls ‚Äî the context in which we are using our resources.</p>
<br><p>
To create these two things we use function D3D11CreateDevice, passing in a pointer to a ID3D11Device and a pointer to ID3D11DeviceContext to be filled out. It looks like this:</p>
<br><div class="code-block-left ">ID3D11Device* baseDevice;<br>ID3D11DeviceContext* baseDeviceContext;<br>D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_11_0 }; <span style="color: #7D7D7D;">//we just want d3d 11 features, not below</span><br>UINT creationFlags = D3D11_CREATE_DEVICE_BGRA_SUPPORT; <br><span style="color: #DAB98F;">#if </span><span style="color: #CD950C;">defined</span><span style="color: #A08563;">(</span>DEBUG_BUILD<span style="color: #A08563;">)</span><br>creationFlags |= D3D11_CREATE_DEVICE_DEBUG;<br><span style="color: #DAB98F;">#endif </span><br>HRESULT hResult = <span style="color: #CD950C;">D3D11CreateDevice</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span>D3D_DRIVER_TYPE_HARDWARE, <span style="color: #7D7D7D;">//hardware rendering instead of software rendering</span><br><span style="color: #6B8E23;">0, </span>creationFlags, <br>featureLevels, <span style="color: #CD950C;">ARRAYSIZE</span><span style="color: #A08563;">(</span>featureLevels<span style="color: #A08563;">)</span>,<br>D3D11_SDK_VERSION, &baseDevice, <br><span style="color: #6B8E23;">0, </span>&baseDeviceContext<span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">FAILED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>{<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">MessageBoxA</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span><span style="color: #CD950C;">"D3D11CreateDevice</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span> failed", "Fatal Error", MB_OK<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">return </span><span style="color: #CD950C;">GetLastError</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>}<br></div><br><p>
We want Direct11 features, hardware rendering, a device with BGRA support and in a debug build we want to create a debug device to find errors in our program.</p>
<br><p>
There‚Äôs one more catch here. There are newer versions of ID3D11DeviceContext and ID3D11DeviceContext aptly called ID3D11Device1 and ID3D11DeviceContext1 which have more functionality. Since we would rather have these, we query the device we just created to get a newer one. It looks like this:</p>
<br><div class="code-block-left ">ID3D11Device1* d3d11Device;<br>ID3D11DeviceContext1* d3d11DeviceContext;<br><span style="color: #7D7D7D;">// Get 1.1 interface of D3D11 Device and Context</span><br>hResult = <span style="color: #CD950C;">baseDevice-&gt;QueryInterface</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">__uuidof</span><span style="color: #A08563;">(</span>ID3D11Device1<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>void**<span style="color: #A08563;">)</span>&d3d11Device<span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">baseDevice-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>hResult = <span style="color: #CD950C;">baseDeviceContext-&gt;QueryInterface</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">__uuidof</span><span style="color: #A08563;">(</span>ID3D11DeviceContext1<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>void**<span style="color: #A08563;">)</span>&d3d11DeviceContext<span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">baseDeviceContext-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br></div><br><p>
We use QueryInterface to get the type of ID3D11Device1 from our device. And the same on our deviceContext. We then release the original device and device context.</p>
<br><p>
Awesome! Now we can check if this compiles. We‚Äôre going to link to d3d11.lib for it to work. Our command line build script would now look like this:</p>
<br><div class="code-block-left ">cl main.cpp /link user32.lib d3d11.lib<br></div><br><p>
Also make sure you include assert at the top of main.cpp</p>
<br><div class="code-block-left ">include &lt;assert.h&gt;<br></div><br><hr><h3>Activate the Debug Layer</h3><br><br><p>
Great! Next we‚Äôre going to activate the debug layer in our deviceContext. You saw when we made the deviceContext, we asked for a debug compatible context with the flag D3D11_CREATE_DEVICE_DEBUG. To enable break on d3d errors we again query the deviceContext.</p>
<br><div class="code-block-left "><span style="color: #DAB98F;">#ifdef </span>DEBUG_BUILD<br><span style="color: #7D7D7D;">// Set up debug layer to break on D3D11 errors</span><br>ID3D11Debug *d3dDebug = nullptr;<br><span style="color: #CD950C;">d3d11Device-&gt;QueryInterface</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">__uuidof</span><span style="color: #A08563;">(</span>ID3D11Debug<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>void**<span style="color: #A08563;">)</span>&d3dDebug<span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">#if </span><span style="color: #A08563;">(</span>d3dDebug<span style="color: #A08563;">)</span><br>{<br>&emsp;&emsp;&emsp;&emsp;ID3D11InfoQueue *d3dInfoQueue = nullptr;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">if </span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">d3dDebug-&gt;QueryInterface</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">__uuidof</span><span style="color: #A08563;">(</span>ID3D11InfoQueue<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>void**<span style="color: #A08563;">)</span>&d3dInfoQueue<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span><span style="color: #A08563;">)</span><br>&emsp;&emsp;&emsp;&emsp;{<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">d3dInfoQueue-&gt;SetBreakOnSeverity</span><span style="color: #A08563;">(</span>D3D11_MESSAGE_SEVERITY_CORRUPTION, true<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">d3dInfoQueue-&gt;SetBreakOnSeverity</span><span style="color: #A08563;">(</span>D3D11_MESSAGE_SEVERITY_ERROR, true<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">d3dInfoQueue-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;}<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">d3dDebug-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>}<br><span style="color: #DAB98F;">#endif</span><br></div><br><p>
We get the ID3D11Debug object from our device using QueryInterface. Once we‚Äôve got that, we can get the d3dInfoQueue from it. We then use the SetBreakOnSeverity function to say what errors we want to break on. </p>
<br><a target='_blank' href='https://docs.microsoft.com/en-us/windows/win32/api/d3d12sdklayers/ne-d3d12sdklayers-d3d12_message_severity'> You can see other options to set in this link. üëÜ</a><br><br><hr><h3>Make the Swap Chain</h3><br><br><p>
<img src='./photos/directX_lesson1_pictures/directx2.png' style='width: 60%;'></p>
<br><p>
The next step is to create a SwapChain. This is a collection of buffers that are used for displaying frames to the user. We render to one of these buffers in the swap chain while one is drawn to the screen. More than one buffer is used to avoid tearing. This happens when we try render to the same buffer while it‚Äôs being drawn to the monitor, resulting in an old image on the upper half of the screen, with the new image on the lower one. Instead we have 2 or more buffers that we can ping-pong between. We draw to one (named the backbuffer), while the other is being displayed to the user.</p>
<br><p>
<img src='./photos/directX_lesson1_pictures/directx3.png' style='width: 60%;'></p>
<br><p>
To create the SwapChain we first need to create DXGI Factory which is used for generating objects that handle fullscreen transitions (namely the swapchain). It‚Äôs another case of using QueryInterface and other helper functions to drill down and get the final object we need. It looks like this:</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">// Get DXGI Factory (needed to create Swap Chain)</span><br>IDXGIFactory2* dxgiFactory;<br>{<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #7D7D7D;">// First, retrieve the underlying DXGI Device from the D3D Device      IDXGIDevice1* dxgiDevice;</span><br>&emsp;&emsp;&emsp;&emsp;HRESULT hResult = <span style="color: #CD950C;">d3d11Device-&gt;QueryInterface</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">__uuidof</span><span style="color: #A08563;">(</span>IDXGIDevice1<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>void**<span style="color: #A08563;">)</span>&dxgiDevice<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #7D7D7D;">// Identify the physical adapter (GPU or card) this device is running on.</span><br>&emsp;&emsp;&emsp;&emsp;IDXGIAdapter* dxgiAdapter;<br>&emsp;&emsp;&emsp;&emsp;hResult = <span style="color: #CD950C;">dxgiDevice-&gt;GetAdapter</span><span style="color: #A08563;">(</span>&dxgiAdapter<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">dxgiDevice-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;DXGI_ADAPTER_DESC adapterDesc;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">dxgiAdapter-&gt;GetDesc</span><span style="color: #A08563;">(</span>&adapterDesc<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #7D7D7D;">//the graphics card that is being used by this progam </span><br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">OutputDebugStringA</span><span style="color: #A08563;">(</span>"Graphics Device: "<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">OutputDebugStringW</span><span style="color: #A08563;">(</span>adapterDesc.Description<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #7D7D7D;">// And obtain the factory object that created it.</span><br>&emsp;&emsp;&emsp;&emsp;hResult = <span style="color: #CD950C;">dxgiAdapter-&gt;GetParent</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">__uuidof</span><span style="color: #A08563;">(</span>IDXGIFactory2<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>void**<span style="color: #A08563;">)</span>&dxgiFactory<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">dxgiAdapter-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>}<br></div><br><p>
We get the dxgiDevice from our d3d11Device. Then we call GetAdapter we gives us back the video adapter (IDXGIAdapter) directX is using ‚Äî this represents your graphics card. We can see specifically what it is, using the GetDesc function on it as seen above-in my case it‚Äôs using the integrated graphics card.</p>
<br><p>
The parent of the adpater is the dxgiFactory that was created when we create our d3d11Device. Phew! We‚Äôve got our dxgiFactory that is in charge of creating the SwapChain[1]. So now let‚Äôs create it!</p>
<br><hr><p>
Now we will create our SwapChain. We use the function CreateSwapChainForHwnd. We also need to create the description of the buffer we want to create. What pixel format it will be in (we want 8bits per color B8G8R8A8 also want the output to be SRGB). The width and height of it. Whether it is a multi-sample buffer. How many buffers we want in our swapchain (we want at least 2 to avoid tearing). How we want our back buffer to respond when the window is a different aspect-ratio and size.</p>
<br><p>
This is what that looks like:</p>
<br><div class="code-block-left ">DXGI_SWAP_CHAIN_DESC1 d3d11SwapChainDesc = {};<br>d3d11SwapChainDesc.Width = <span style="color: #6B8E23;">0; </span><span style="color: #7D7D7D;">// use window width</span><br>d3d11SwapChainDesc.Height = <span style="color: #6B8E23;">0; </span><span style="color: #7D7D7D;">// use window height</span><br>d3d11SwapChainDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;<br>d3d11SwapChainDesc.SampleDesc.Count = <span style="color: #6B8E23;">1;</span><br>d3d11SwapChainDesc.SampleDesc.Quality = <span style="color: #6B8E23;">0;</span><br>d3d11SwapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;<br>d3d11SwapChainDesc.BufferCount = <span style="color: #6B8E23;">2;</span><br>d3d11SwapChainDesc.Scaling = DXGI_SCALING_STRETCH;<br>d3d11SwapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;<br>d3d11SwapChainDesc.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED;<br>d3d11SwapChainDesc.Flags = <span style="color: #6B8E23;">0;</span><br></div><br><p>
Since these are the buffers that we are drawing to, we set the BufferUsage to DXGI_USAGE_RENDER_TARGET_OUTPUT. Since we aren‚Äôt reading from the buffer, we don‚Äôt care about the alphaMode. We also must choose an option for how the buffer is presented to the screen in the SwapEffect variable. Since we are rendering the complete scene from scratch into the buffer each frame, we don‚Äôt need to rely on past rendering to still exist in the buffer. Because of this we use the swap effect DXGI_SWAP_EFFECT_DISCARD, instead of the DXGI_SWAP_EFFECT_SEQUENTIAL [2].</p>
<br><p>
Now that we‚Äôve got our SwapChainDescription, we are ready to create it using CreateSwapChainForHwnd, passing in our device, our description and our windowHandle:</p>
<br><div class="code-block-left ">HRESULT hResult = <span style="color: #CD950C;">dxgiFactory-&gt;CreateSwapChainForHwnd</span><span style="color: #A08563;">(</span>d3d11Device, hwnd, &d3d11SwapChainDesc, <span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span>&d3d11SwapChain<span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br><span style="color: #CD950C;">dxgiFactory-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br></div><br><p>
We also release our pointer to the dxgiFactory since we no longer need it.</p>
<br><hr><h3>Create a Render View Target</h3><br><br><p>
<img src='./photos/directX_lesson1_pictures/directx4.png' style='width: 60%;'></p>
<br><p>
Ok, we‚Äôve got our d3d11Device, our d3d11DeviceContext and our SwapChain. We these three things we are able to render to our window.</p>
<br><p>
The very last thing we need to do before we do this is to get access to the backbuffer in our SwapChain to draw to. This is represented as a ID3D11RenderTargetView, which looks after the writable part ofwhat we‚Äôre rendering into. </p>
<br><p>
To get this from the backbuffer in our SwapChain we do the following:</p>
<br><div class="code-block-left "><span style="color: #7D7D7D;">// Create Framebuffer Render Target</span><br>ID3D11RenderTargetView* d3d11FrameBufferView;<br>{<br>&emsp;&emsp;&emsp;&emsp;ID3D11Texture2D* d3d11FrameBuffer;<br>&emsp;&emsp;&emsp;&emsp;HRESULT hResult = <span style="color: #CD950C;">d3d11SwapChain-&gt;GetBuffer</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">0, </span><span style="color: #CD950C;">__uuidof</span><span style="color: #A08563;">(</span>ID3D11Texture2D<span style="color: #A08563;">)</span><span style="color: #CD950C;">, </span><span style="color: #A08563;">(</span>void**<span style="color: #A08563;">)</span>&d3d11FrameBuffer<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;hResult = <span style="color: #CD950C;">d3d11Device-&gt;CreateRenderTargetView</span><span style="color: #A08563;">(</span>d3d11FrameBuffer, <span style="color: #6B8E23;">0, </span>&d3d11FrameBufferView<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">assert</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">SUCCEEDED</span><span style="color: #A08563;">(</span>hResult<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">d3d11FrameBuffer-&gt;Release</span><span style="color: #A08563;">(</span><span style="color: #A08563;">)</span>;<br>}<br></div><br><p>
We use the GetBuffer function from our swapChain, passing the buffer index as zero, since this is the only buffer we can acces with the swap effect DXGI_SWAP_EFFECT_DISCARD. Once we get it, we can then create a RenderTargetView.</p>
<br><p>
So we‚Äôve got all the tools to do the rendering for us (the deviceContext and swapchain) and we‚Äôve got the buffer we‚Äôre going to render into ‚Äî the RenderTargetView of the backbuffer.</p>
<br><p>
Time to get rendering!</p>
<br><hr><h3>Using DirectX in our game loop</h3><br><br><p>
<img src='./photos/directX_lesson1_pictures/directx5.png' style='width: 60%;'></p>
<br><p>
In our game loop, after we‚Äôve processed our messages, we‚Äôre going to clear the renderTarget to a blue color. It looks like this:</p>
<br><div class="code-block-left ">MSG msg = {};<br><span style="color: #CD950C;">while</span><span style="color: #A08563;">(</span><span style="color: #CD950C;">PeekMessageW</span><span style="color: #A08563;">(</span>&msg, <span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span><span style="color: #6B8E23;">0, </span>PM_REMOVE<span style="color: #A08563;">)</span><span style="color: #A08563;">)</span><br>{<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">if</span><span style="color: #A08563;">(</span>msg.message == WM_QUIT<span style="color: #A08563;">)</span><br>&emsp;&emsp;&emsp;&emsp;isRunning = false;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">TranslateMessage</span><span style="color: #A08563;">(</span>&msg<span style="color: #A08563;">)</span>;<br>&emsp;&emsp;&emsp;&emsp;<span style="color: #CD950C;">DispatchMessageW</span><span style="color: #A08563;">(</span>&msg<span style="color: #A08563;">)</span>;<br>}<br>FLOAT backgroundColor[4] = { <span style="color: #6B8E23;">0.1f, </span><span style="color: #6B8E23;">0.2f, </span><span style="color: #6B8E23;">0.6f, </span><span style="color: #6B8E23;">1.0f </span>};<br><span style="color: #CD950C;">d3d11DeviceContext-&gt;ClearRenderTargetView</span><span style="color: #A08563;">(</span>d3d11FrameBufferView, backgroundColor<span style="color: #A08563;">)</span>;<br></div><br><p>
We‚Äôre using our d3d11DeviceContext which looks after the rendering commands to clear a render targetView ‚Äî the backbuffer one we created.</p>
<br><hr><h3>Present Our Frame</h3><br><br><p>
<img src='./photos/directX_lesson1_pictures/directx6.png' style='width: 60%;'></p>
<br><p>
Then to finish the frame off we use our swapchain, calling present. This says we‚Äôre done all rendering for this frame, it‚Äôs time to present. This is the equivalent to the OpenGL command wglSwapBuffers.</p>
<br><div class="code-block-left "><span style="color: #CD950C;">d3d11SwapChain-&gt;Present</span><span style="color: #A08563;">(</span><span style="color: #6B8E23;">1, </span><span style="color: #6B8E23;">0</span><span style="color: #A08563;">)</span>;<br></div><br><p>
The first argument is the sync interval-how were syncing with V-sync. A zero means don‚Äôt wait for v-sync, just display the image now. A value 1 to 4 means synchronize presentation after these number of vsyncs. i.e how many number of vsyncs we wait for till we can keep rendering. We want to keep up with the montior refresh rate, so we choose one. This value is the same as <i>wglSwapIntervalEXT()</i> with openGL.</p>
<br><p>
The second argument is how we want to present the frames to the output. A zero means we present a frame from each buffer starting with the current buffer ‚Äî that is we‚Äôre using the sequencing ability of writing to one frame while the other one is being read, and flipping them on present.</p>
<br><hr><p>
We made it. When we compile the game and run it we should hopefully get a light blue screen.</p>
<br><p>
<img src='./photos/directX_lesson1_pictures/directx_blue_screen.png' style='width: 60%;'></p>
<br><a target='_blank' href='https://github.com/Olster1/directX11_tutorial/blob/main/lesson2/main.cpp'> You can see the full code here üëÜ</a><br><br><a target='_blank' href='https://github.com/Olster1/directX11_tutorial/blob/main/lesson2_withTiming/main.cpp'> You can also find a version that mesures the frame time here (you need to run it in Visual Studio to see the Console Output) üëÜ</a><br><br><hr><p>
You made it through the whole Part 1 lesson. Congratulate yourself! It‚Äôs no mean feat doing computer graphics at a low level.</p>
<br><p>
In Part 2 we‚Äôll render a colorful triangle to the screen, well on the way to rendering full 3d models. See you then!</p>
<br><a target='_blank' href='https://oliver532.substack.com/p/coming-soon?r=9i1j7&utm_campaign=post&utm_medium=web&utm_source=copy'> Sign up to my Newsletter to get a weekly email about what I‚Äôm up to, what I‚Äôm learning and what I‚Äôm teaching. üëÜ</a><br><br><hr><h2>QUIZ</h2><br><p>
<b>What function to we use to create a Window?</b></p>
<br><p>
[CreateWindowExW]</p>
<br><p>
<b>What do we need to pass to CreateWindow?</b></p>
<br><p>
[A windowClass which we register before creating a window. It also contains the function pointer to out event callback wndProc for handling input]</p>
<br><p>
<b>What do we do at the start of every game loop?</b></p>
<br><p>
[We process the messages that have come in using PeekMessage.]</p>
<br><p>
<b>When is our WndProc function called?</b></p>
<br><p>
[When we use DispatchMessage()]</p>
<br><p>
<b>What were the four directX objects we needed to create before rendering to our Window?</b></p>
<br><p>
[d3d11Device, d3d11DeviceContext, IDXGISwapChain, and a ID3D11RenderTargetView. At least one Device is needed to use DirectX. It‚Äôs in charge of creating resources. The DeviceContext is used to set the state in which we will use GPU. We use the DeviceContext the most during rendering our scene. The RenderTargetView represents the buffer we‚Äôre drawing into]</p>
<br><p>
<b>What function submits our final buffer to the GPU?</b></p>
<br><p>
[swapChain->Present() function. It takes two parameters: the sync interval and how we want to display the buffers]</p>
<br><p>
<b>Why do we need at least two buffers in the swap chain?</b></p>
<br><p>
[To stop tearing ‚Äî that is we start updating the buffer that is being displayed to the screen, causing one half of the buffer to be the original image and the other half the new one we are writing to it. Instead, we ping pong between the buffers in the SwapChain]</p>
<br><hr><h2>Notes:</h2><br><p>
[1] It should be noted you can just use D3D11CreateDeviceAndSwapChain which creates both at the same time. It was separated to show more of what is happening behind the scenes.</p>
<br><p>
[2] There are newer versions of these values: DXGI_SWAP_EFFECT_FLIP_DISCARD and DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL which are recomended to be used. Although these are only avaiable on Windows 10</p>
<br></div>
</div>
</div>
<br><br></div></body></html>